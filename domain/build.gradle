/*
 * Copyright 2012 - 2013 Silvio Wangler (silvio.wangler@gmail.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *          http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import org.hibernate.boot.Metadata
import org.hibernate.boot.MetadataSources
import org.hibernate.boot.internal.IdGeneratorInterpreterImpl
import org.hibernate.boot.model.naming.ImplicitNamingStrategy
import org.hibernate.boot.model.naming.PhysicalNamingStrategy
import org.hibernate.boot.registry.StandardServiceRegistryBuilder
import org.hibernate.cfg.AvailableSettings
import org.hibernate.tool.hbm2ddl.SchemaExport
import org.hibernate.tool.schema.TargetType
import org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy
import org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy

import javax.persistence.Entity

buildscript {
    repositories {
        jcenter()
        maven { url "https://repo.spring.io/snapshot" }
        maven { url "https://repo.spring.io/milestone" }
    }
    dependencies {
        classpath gradleApi()
        classpath 'org.hibernate:hibernate-core:5.2.12.Final'
        classpath 'org.springframework.data:spring-data-jpa:2.0.1.RELEASE'
        classpath "org.springframework.boot:spring-boot:${springBootVersion}"
    }
}

dependencies {
    compile 'org.hibernate:hibernate-core'
    compile 'org.springframework.data:spring-data-jpa'
}

sourceSets {
    main {
        resources {
            srcDirs = ['src/main/generated', 'src/main/resources']
        }
    }
}

task cleanGenerated(type: Delete) {

    def target = new File(project.projectDir, 'src/main/generated')
    if (target.exists()) {
        delete = target.listFiles()
    }
}


task ddl(type: HibernateJpaSchemaGenerationTask, dependsOn: [compileJava])
jar.dependsOn << ddl
processResources.dependsOn << ddl
clean.dependsOn << cleanGenerated

class HibernateJpaSchemaGenerationTask extends DefaultTask {

    private Map<String, String> dialects = [
            'ORACLE8I'     : 'org.hibernate.dialect.Oracle8iDialect',
            'ORACLE10G'    : 'org.hibernate.dialect.Oracle10gDialect',
            'ORACLE12C'    : 'org.hibernate.dialect.Oracle12cDialect',
            'MYSQL'        : 'org.hibernate.dialect.MySQLDialect',
            'MYSQL5'       : 'org.hibernate.dialect.MySQL5Dialect',
            'MYSQL5INNODB' : 'org.hibernate.dialect.MySQL5InnoDBDialect',
            'MYSQL57INNODB': 'org.hibernate.dialect.MySQL57InnoDBDialect',
            'HSQL'         : 'org.hibernate.dialect.HSQLDialect',
            'H2'           : 'org.hibernate.dialect.H2Dialect',
            'PostgreSQL'   : 'org.hibernate.dialect.PostgreSQLDialect',
            'PostgreSQL9'  : 'org.hibernate.dialect.PostgreSQL9Dialect',
            'PostgreSQL95' : 'org.hibernate.dialect.PostgreSQL95Dialect'
    ]

    private URLClassLoader loader

    def source = project.sourceSets.main.output.classesDirs[0]
    def target = new File(project.projectDir, 'src/main/generated')

    @InputFiles
    def getInputFiles() {
        this.loader = new URLClassLoader(source.toURI().toURL() as URL[], getClass().getClassLoader())

        def jpaEntities = findJpaEntities(this.loader)
        if (jpaEntities && !jpaEntities.isEmpty()) {
            def inputFiles = jpaEntities.collect { c ->
                project.sourceSets.main.java.files.find { file ->
                    if (file.name.endsWith(c.simpleName + '.java')) {
                        file
                    }
                }
            }
            logger.debug("Input files for this task are ${inputFiles.dump()}")
            return inputFiles
        }
        logger.debug('No input files should be considered')
        false
    }

    @OutputFiles
    def getDdlFiles() {
        def outputFiles = dialects.collect { new File(target, "ddl_${it.key.toLowerCase()}_create.sql") }
        outputFiles.addAll dialects.collect { new File(target, "ddl_${it.key.toLowerCase()}_drop.sql") }
        logger.debug("Expected output files for this task are ${outputFiles.dump()}")
        return outputFiles
    }

    @TaskAction
    def performSchemaGeneration() {

        if (!target.exists()) {
            assert target.mkdir()
        }

        def jpaEntities = findJpaEntities(new URLClassLoader(source.toURI().toURL() as URL[], this.class.classLoader))

        ClassLoader prev = Thread.currentThread().getContextClassLoader()

        try {
            // Need to set our class loader to the current thread
            this.loader = new URLClassLoader(source.toURI().toURL() as URL[], this.class.classLoader)
            Thread.currentThread().setContextClassLoader(this.loader)

            for (Map.Entry<String, String> entry : dialects.entrySet()) {

                String key = entry.key
                String value = entry.value

                File fileCreate = new File(target, "ddl_${key.toLowerCase()}_create.sql")
                File fileDrop = new File(target, "ddl_${key.toLowerCase()}_drop.sql")

                logger.debug('Writing to dir {}', target.absolutePath)

                StandardServiceRegistryBuilder regBuilder = new StandardServiceRegistryBuilder()
                regBuilder.applySetting(AvailableSettings.DIALECT, value)


                MetadataSources metadataSources = new MetadataSources(regBuilder.build())

                jpaEntities.each { Class jpaEntity ->
                    metadataSources.addAnnotatedClass(jpaEntity)
                }

                ImplicitNamingStrategy implicitNamingStrategy = new SpringImplicitNamingStrategy()
                PhysicalNamingStrategy physicalNamingStrategy = new SpringPhysicalNamingStrategy()

                Metadata metadata = metadataSources.getMetadataBuilder()
                        .applyTempClassLoader(this.loader)
                        .applyIdGenerationTypeInterpreter(new IdGeneratorInterpreterImpl.LegacyFallbackInterpreter())
                        .applyImplicitNamingStrategy(implicitNamingStrategy)
                        .applyPhysicalNamingStrategy(physicalNamingStrategy)
                        .build()

                SchemaExport export = new SchemaExport()
                export.setDelimiter(";")
                export.setFormat(true)
                export.setOutputFile(fileCreate.path)

                EnumSet targetTypes = EnumSet.of(TargetType.SCRIPT)
                export.createOnly(targetTypes, metadata)

                export.setOutputFile(fileDrop.path)
                export.execute(targetTypes, org.hibernate.tool.hbm2ddl.SchemaExport.Action.DROP, metadata)
            }

            dialects.each { key, value ->

            }
        }
        catch (Exception e) {
            logger.error('Error while schema generation', e)
        }
        finally {
            logger.info("Setting previous class loader context")
            Thread.currentThread().setContextClassLoader(prev)
        }
    }

    private List<Class> findJpaEntities(loader) {

        if (!source.exists()) return []

        def clazzez = []

        source.eachFileRecurse { file ->
            if (file.name.endsWith('.class')) {
                def classRelPath = file.absolutePath - source.absolutePath
                clazzez << classRelPath[1..-7].replace(System.properties['file.separator'], '.')
            }
        }

        List<Class> jpaEntities = []

        for (String clazz : clazzez) {
            try {
                logger.debug("Trying to load class ${clazz}")
                Class possibleJpaEntity = Class.forName(clazz, true, loader)
                logger.debug("Class ${clazz} sucessfully loaded")

                if (possibleJpaEntity?.isAnnotationPresent(Entity.class)) {
                    logger.info("JPA entity detected: ${possibleJpaEntity}")
                    jpaEntities << possibleJpaEntity
                } else {
                    logger.debug("Ignoring class ${possibleJpaEntity.canonicalName} since it has no javax.persistence.Entity annotation present")
                }

            } catch (Exception e) {
                logger.error('Error while trying to detect JPA annotated entities', e)
            }
        }
        return jpaEntities
    }
}